# WS2812B_Firmware
Firmware for STM32F103C8T6 to control individually addressable LED strip WS2812B
I've developed this firmware using STM's SW4STM32 or System Workbench for STM32 which is provided by them free of charge.

1. Principle of operation
The WS2812B uses a 1 wire communication protocol with the following specifications:
 - Clock speed of up 800 KHz (Period of 1250 nS).
 - Varying the pulse width determines if a logic one or a logic zero is being sent. 
 - A logic zero is generated by a pulse width of 400nS (±150ns) high and 850nS low.
 - A logic one is generated by a pulse width of 800nS (±150ns) high and 450nS low.
 - Each LED on the strip requires 8bit of Green, 8bit of Red and 8bit of Blue for a total of 24 bits.
 - A reset or latch signal >= 50 µS is required at the end of the data sequence.
 
In order to produce the control signal, I'm using the hardware Timer 4 Channel 1 and the DMA module with a circular buffer on pin PB6.
This method yields nearly zero CPU usage, very accurate timing and continious refreshing, but is very RAM inefficient.
The state of all LEDs including the reset time is stored in a buffer which elements are 1 byte each.
The length of this buffer is determined by the number of LEDs on the strip. Example 300 LEDs x 24 bits = 7200 elements.
Additionally, since the reset/latch signal should be 50µS and one clock cycle is 1.25µS, another 50/1.25 = 40 elements are added to the array for a grand total of 7240.
In a microcontroller application usually all variables are statically allocated. To give more flexibility, the array is
dinamically allocated depending on the size of LED strip passed during the instantiation of the C# class.
Note that this microcontroller has 20K ram and it will probably not handle a strip bigger than 600 LEDs as it will run out of RAM.

  - To generate a 1250 nS pulse, TIM4 is configured with a period of 90 cycles since the MCU clock runs at 72 MHz / 90 cycles = 800 KHz.
  - T_ZERO = 29 cycles = 400nS. T_ONE = 58 cycles = 800nS.
  - Bit order of the colors = G7 G6 G5 G4 G3 G2 G1 G0 R7 R6 R5 R4 R3 R2 R1 R0 B7 B6 B5 B4 B3 B2 B1 B0

Values T_ZERO and T_ONE are stored into the buffer using the above bit order.
On each TIM4 period a DMA request is generated, the DMA controller serves this request by loading the next value from the array to Capture/Compare register and thus setting the pulse width for the next clock cycle.
After each group of 24 bits for each LED have been clocked out, 40 periods of 0 pulse width follow in order to trigger a reset/latch.
Since the DMA is configured to run in a circular buffer, there is no need to restart the process.
To change the color of an LED, I simply modify the contents of the buffer.
A race condition does exist - the DMA might read parts of old state of the buffer and parts of the new state and produce an incorrect color, however the refresh rate is fast enough for this to not be obvious.
To update the entire strip of 300 LEDs, 7240 cycles of 1.25µS are needed. 7240 x 1.25 = 9050 µS or 9.05 ms.

2. Communication and control
The device is currently controlled via USB virtual com port.
A very simple protocol consisting of up to 5 data fields delimited by space is used.
The first field is a command field, the other data fileds are parameters passed together with the command.
I've created a C# class which handles the communication and a WPF application to test it. Clone the WS2812B_GUI.

Firmware methods currently implemented:

* Initializes the LED strip to the number of ledCount.
* NOTE that if there is not enough memory, the device will most likely generate a Hard_Fault rather than gracefully return an error.
uint8_t ws2812b_Init(uint16_t ledCount);

* Turns off entire LED strip by setting G = 0, R = 0, B = 0 for each LED
void ws2812b_SetStripOff();

* Sets the entire LED strip to newColor
void ws2812b_SetStripColor(const ledcolor_t *newColor);

* Rotates the LEDs in a clockwise or counterclockwise direction by a number of rotateBy
void ws2812b_RotateStrip(rotation_t direction, uint16_t rotateBy);

* Copy the LED colors of numLedsToCopy starting at copyFrom and pasting to copyTo
void ws2812b_LedCopy(uint16_t numLedsToCopy, uint16_t copyFrom, uint16_t copyTo);

* Calls ws2812b_LedCopy first, and then it turns off the LED(s) at the old location.
void ws2812b_LedMove(uint16_t numLedsToCopy, uint16_t copyFrom, uint16_t copyTo);

* Sets the LED at positionInStrip to newColor
void ws2812b_LedSet(const uint16_t *positionInStrip, const ledcolor_t *newColor);

* Swap the colors of LEDs at position1 and position2
void ws2812b_LedSwap(uint16_t position1, uint16_t position2);
